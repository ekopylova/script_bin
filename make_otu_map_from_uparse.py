#!/usr/bin/python

"""
Prints a QIIME-compatible OTU map based on the information in a uparse OTU map 
uclust file. Note that the order of sequences in the OTU list is determined by 
the order of hits in the Uclust file, so may not be sensible/important. 
"""


def clusters_from_uparse_file(uc_lines):
    """ Given an open .uc file, return lists (clusters, failures)
    
        ####MODIFIED FROM UCLUST.PY IN PYCOGENT#####
    
        uc_lines: open .uc file, or similar object -- this is the output
         generated by uclust's -uc parameter
         
        This function processes all hit (H) and no hit (N) lines
         to return all clusters, failures, and new_seeds generated in
         a uclust run.
    
    """
    clusters = {}
    failures = []
    # the types of hit lines we're interested in here
    # are hit (H) and no hit (N). Uparse doesn't give seed (S) or library (L)
    # hit types.
    
    for line in uc_lines:
        record = line.strip().split('\t')
        hit_type = record[0]
        # sequence identifiers from the fasta header lines only 
        # (no comment data) are stored to identify a sequence in 
        # a cluster -- strip off any comments here as this value
        # is used in several places
        query_id = record[8].split()[0]
        target_cluster = record[9].split()[0]
        
        if hit_type == 'H':
            # if target cluster not yet in dict, add the key
            if target_cluster not in clusters:
                clusters[target_cluster] = []
            # Now add the query id to the list for that cluster
            clusters[target_cluster].append(query_id)
        elif hit_type == 'N':
            # a failure was identified -- add it to the failures list
            failures.append(query_id)
        else:
            # shouldn't be possible to get here, but provided for 
            # clarity
            raise Exception,\
             "Unexpected result parsing line:\n%s" % '\t'.join(record)
    
    # will need to return the full clusters dict, I think, to support
    # useful identifiers in reference database clustering
    # 
    #return  clusters.values(), failures
    # 
    return  clusters, failures


import argparse
import os

parser = argparse.ArgumentParser(description='Turn uparse map into QIIME map')
parser.add_argument('-f','--failure_path', 
                   help='path to write failures')
parser.add_argument('-l','--log_path',
                   help='path to write log file')
parser.add_argument('-o', '--output',
                   help='path to write otu map file')
parser.add_argument('-u','--uparse_map',
                   help='path to uparse mapping file')

args = parser.parse_args()

failure_path = args.failure_path
log_path = args.log_path
result_path = args.output
uparse_map = args.uparse_map

try:
    uparse_lines = open(uparse_map,'r')
except IOError:
    print "Couldn't open uparse mapping file. Check file path!"

# parse the otu map
clusters, failures = clusters_from_uparse_file(uparse_lines)

# clean up any temp files that were created

log_lines = ''
log_lines += 'Num OTUs:%d\n' % len(clusters)
log_lines += 'Num failures:%d\n' % len(failures)


if failure_path:
    failure_file = open(failure_path,'w')
    failure_file.write('\n'.join(failures))
    failure_file.close()
    

if log_path:
    log_file = open(log_path, 'w')
    log_file.write(log_lines)
    log_file.close()
    
if not result_path:
    print "Did you provide an output path?"
else:
    result_out = open(result_path, "w")
    for cluster_id in clusters:
        result_out.write(cluster_id + "\t" +\
         "\t".join(clusters[cluster_id]) + '\n')



